<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# freelru

```go
import "github.com/fufuok/freelru"
```

## Index

- [func MakeHasher\[T comparable\]\(\) func\(T\) uint32](<#MakeHasher>)
- [type Cache](<#Cache>)
- [type HashKeyCallback](<#HashKeyCallback>)
- [type LRU](<#LRU>)
  - [func New\[K comparable, V any\]\(capacity uint32, hash HashKeyCallback\[K\]\) \(\*LRU\[K, V\], error\)](<#New>)
  - [func NewDefault\[K comparable, V any\]\(capacity uint32, lifetime ...time.Duration\) \(\*LRU\[K, V\], error\)](<#NewDefault>)
  - [func NewWithSize\[K comparable, V any\]\(capacity, size uint32, hash HashKeyCallback\[K\]\) \(\*LRU\[K, V\], error\)](<#NewWithSize>)
  - [func NewWithSizeDefault\[K comparable, V any\]\(capacity, size uint32, lifetime ...time.Duration\) \(\*LRU\[K, V\], error\)](<#NewWithSizeDefault>)
  - [func \(lru \*LRU\[K, V\]\) Add\(key K, value V\) \(evicted bool\)](<#LRU[K, V].Add>)
  - [func \(lru \*LRU\[K, V\]\) AddWithLifetime\(key K, value V, lifetime time.Duration\) \(evicted bool\)](<#LRU[K, V].AddWithLifetime>)
  - [func \(lru \*LRU\[K, V\]\) Contains\(key K\) \(ok bool\)](<#LRU[K, V].Contains>)
  - [func \(lru \*LRU\[K, V\]\) Get\(key K\) \(value V, ok bool\)](<#LRU[K, V].Get>)
  - [func \(lru \*LRU\[K, V\]\) Keys\(\) \[\]K](<#LRU[K, V].Keys>)
  - [func \(lru \*LRU\[K, V\]\) Len\(\) int](<#LRU[K, V].Len>)
  - [func \(lru \*LRU\[K, V\]\) Metrics\(\) Metrics](<#LRU[K, V].Metrics>)
  - [func \(lru \*LRU\[K, V\]\) Peek\(key K\) \(value V, ok bool\)](<#LRU[K, V].Peek>)
  - [func \(lru \*LRU\[K, V\]\) PrintStats\(\)](<#LRU[K, V].PrintStats>)
  - [func \(lru \*LRU\[K, V\]\) Purge\(\)](<#LRU[K, V].Purge>)
  - [func \(lru \*LRU\[K, V\]\) Remove\(key K\) \(removed bool\)](<#LRU[K, V].Remove>)
  - [func \(lru \*LRU\[K, V\]\) ResetMetrics\(\) Metrics](<#LRU[K, V].ResetMetrics>)
  - [func \(lru \*LRU\[K, V\]\) SetLifetime\(lifetime time.Duration\)](<#LRU[K, V].SetLifetime>)
  - [func \(lru \*LRU\[K, V\]\) SetOnEvict\(onEvict OnEvictCallback\[K, V\]\)](<#LRU[K, V].SetOnEvict>)
- [type Metrics](<#Metrics>)
- [type OnEvictCallback](<#OnEvictCallback>)
- [type ShardedLRU](<#ShardedLRU>)
  - [func NewSharded\[K comparable, V any\]\(capacity uint32, hash HashKeyCallback\[K\]\) \(\*ShardedLRU\[K, V\], error\)](<#NewSharded>)
  - [func NewShardedDefault\[K comparable, V any\]\(capacity uint32, lifetime ...time.Duration\) \(\*ShardedLRU\[K, V\], error\)](<#NewShardedDefault>)
  - [func NewShardedWithSize\[K comparable, V any\]\(shards, capacity, size uint32, hash HashKeyCallback\[K\]\) \(\*ShardedLRU\[K, V\], error\)](<#NewShardedWithSize>)
  - [func NewShardedWithSizeDefault\[K comparable, V any\]\(shards, capacity, size uint32, lifetime ...time.Duration\) \(\*ShardedLRU\[K, V\], error\)](<#NewShardedWithSizeDefault>)
  - [func \(lru \*ShardedLRU\[K, V\]\) Add\(key K, value V\) \(evicted bool\)](<#ShardedLRU[K, V].Add>)
  - [func \(lru \*ShardedLRU\[K, V\]\) AddWithLifetime\(key K, value V, lifetime time.Duration\) \(evicted bool\)](<#ShardedLRU[K, V].AddWithLifetime>)
  - [func \(lru \*ShardedLRU\[K, V\]\) Contains\(key K\) \(ok bool\)](<#ShardedLRU[K, V].Contains>)
  - [func \(lru \*ShardedLRU\[K, V\]\) Get\(key K\) \(value V, ok bool\)](<#ShardedLRU[K, V].Get>)
  - [func \(lru \*ShardedLRU\[K, V\]\) Keys\(\) \[\]K](<#ShardedLRU[K, V].Keys>)
  - [func \(lru \*ShardedLRU\[K, V\]\) Len\(\) \(length int\)](<#ShardedLRU[K, V].Len>)
  - [func \(lru \*ShardedLRU\[K, V\]\) Metrics\(\) Metrics](<#ShardedLRU[K, V].Metrics>)
  - [func \(lru \*ShardedLRU\[K, V\]\) Peek\(key K\) \(value V, ok bool\)](<#ShardedLRU[K, V].Peek>)
  - [func \(lru \*ShardedLRU\[K, V\]\) PrintStats\(\)](<#ShardedLRU[K, V].PrintStats>)
  - [func \(lru \*ShardedLRU\[K, V\]\) Purge\(\)](<#ShardedLRU[K, V].Purge>)
  - [func \(lru \*ShardedLRU\[K, V\]\) Remove\(key K\) \(removed bool\)](<#ShardedLRU[K, V].Remove>)
  - [func \(lru \*ShardedLRU\[K, V\]\) ResetMetrics\(\) Metrics](<#ShardedLRU[K, V].ResetMetrics>)
  - [func \(lru \*ShardedLRU\[K, V\]\) SetLifetime\(lifetime time.Duration\)](<#ShardedLRU[K, V].SetLifetime>)
  - [func \(lru \*ShardedLRU\[K, V\]\) SetOnEvict\(onEvict OnEvictCallback\[K, V\]\)](<#ShardedLRU[K, V].SetOnEvict>)
- [type SyncedLRU](<#SyncedLRU>)
  - [func NewSynced\[K comparable, V any\]\(capacity uint32, hash HashKeyCallback\[K\]\) \(\*SyncedLRU\[K, V\], error\)](<#NewSynced>)
  - [func NewSyncedDefault\[K comparable, V any\]\(capacity uint32, lifetime ...time.Duration\) \(\*SyncedLRU\[K, V\], error\)](<#NewSyncedDefault>)
  - [func NewSyncedWithSize\[K comparable, V any\]\(capacity, size uint32, hash HashKeyCallback\[K\]\) \(\*SyncedLRU\[K, V\], error\)](<#NewSyncedWithSize>)
  - [func NewSyncedWithSizeDefault\[K comparable, V any\]\(capacity, size uint32, lifetime ...time.Duration\) \(\*SyncedLRU\[K, V\], error\)](<#NewSyncedWithSizeDefault>)
  - [func \(lru \*SyncedLRU\[K, V\]\) Add\(key K, value V\) \(evicted bool\)](<#SyncedLRU[K, V].Add>)
  - [func \(lru \*SyncedLRU\[K, V\]\) AddWithLifetime\(key K, value V, lifetime time.Duration\) \(evicted bool\)](<#SyncedLRU[K, V].AddWithLifetime>)
  - [func \(lru \*SyncedLRU\[K, V\]\) Contains\(key K\) \(ok bool\)](<#SyncedLRU[K, V].Contains>)
  - [func \(lru \*SyncedLRU\[K, V\]\) Get\(key K\) \(value V, ok bool\)](<#SyncedLRU[K, V].Get>)
  - [func \(lru \*SyncedLRU\[K, V\]\) Keys\(\) \(keys \[\]K\)](<#SyncedLRU[K, V].Keys>)
  - [func \(lru \*SyncedLRU\[K, V\]\) Len\(\) \(length int\)](<#SyncedLRU[K, V].Len>)
  - [func \(lru \*SyncedLRU\[K, V\]\) Metrics\(\) Metrics](<#SyncedLRU[K, V].Metrics>)
  - [func \(lru \*SyncedLRU\[K, V\]\) Peek\(key K\) \(value V, ok bool\)](<#SyncedLRU[K, V].Peek>)
  - [func \(lru \*SyncedLRU\[K, V\]\) PrintStats\(\)](<#SyncedLRU[K, V].PrintStats>)
  - [func \(lru \*SyncedLRU\[K, V\]\) Purge\(\)](<#SyncedLRU[K, V].Purge>)
  - [func \(lru \*SyncedLRU\[K, V\]\) Remove\(key K\) \(removed bool\)](<#SyncedLRU[K, V].Remove>)
  - [func \(lru \*SyncedLRU\[K, V\]\) ResetMetrics\(\) Metrics](<#SyncedLRU[K, V].ResetMetrics>)
  - [func \(lru \*SyncedLRU\[K, V\]\) SetLifetime\(lifetime time.Duration\)](<#SyncedLRU[K, V].SetLifetime>)
  - [func \(lru \*SyncedLRU\[K, V\]\) SetOnEvict\(onEvict OnEvictCallback\[K, V\]\)](<#SyncedLRU[K, V].SetOnEvict>)


<a name="MakeHasher"></a>
## func [MakeHasher](<https://github.com/fufuok/go-freelru/blob/main/hasher.go#L12>)

```go
func MakeHasher[T comparable]() func(T) uint32
```

MakeHasher creates a fast hash function for the given comparable type. The only limitation is that the type should not contain interfaces inside based on runtime.typehash. Thanks to @puzpuzpuz for the idea in xsync.

<a name="Cache"></a>
## type [Cache](<https://github.com/fufuok/go-freelru/blob/main/cache.go#L22-L67>)



```go
type Cache[K comparable, V any] interface {
    // SetLifetime sets the default lifetime of LRU elements.
    // Lifetime 0 means "forever".
    SetLifetime(lifetime time.Duration)

    // SetOnEvict sets the OnEvict callback function.
    // The onEvict function is called for each evicted lru entry.
    SetOnEvict(onEvict OnEvictCallback[K, V])

    // Len returns the number of elements stored in the cache.
    Len() int

    // AddWithLifetime adds a key:value to the cache with a lifetime.
    // Returns true, true if key was updated and eviction occurred.
    AddWithLifetime(key K, value V, lifetime time.Duration) (evicted bool)

    // Add adds a key:value to the cache.
    // Returns true, true if key was updated and eviction occurred.
    Add(key K, value V) (evicted bool)

    // Get retrieves an element from map under given key.
    Get(key K) (V, bool)

    // Peek retrieves an element from map under given key without updating the
    // "recently used"-ness of that key.
    Peek(key K) (V, bool)

    // Contains checks for the existence of a key, without changing its recent-ness.
    Contains(key K) bool

    // Remove removes an element from the map.
    // The return value indicates whether the key existed or not.
    Remove(key K) bool

    // Keys returns a slice of the keys in the cache, from oldest to newest.
    Keys() []K

    // Purge purges all data (key and value) from the LRU.
    Purge()

    // Metrics returns the metrics of the cache.
    Metrics() Metrics

    // ResetMetrics resets the metrics of the cache and returns the previous state.
    ResetMetrics() Metrics
}
```

<a name="HashKeyCallback"></a>
## type [HashKeyCallback](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L32>)

HashKeyCallback is the function that creates a hash from the passed key.

```go
type HashKeyCallback[K comparable] func(K) uint32
```

<a name="LRU"></a>
## type [LRU](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L63-L80>)

LRU implements a non\-thread safe fixed size LRU cache.

```go
type LRU[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func [New](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L112>)

```go
func New[K comparable, V any](capacity uint32, hash HashKeyCallback[K]) (*LRU[K, V], error)
```

New constructs an LRU with the given capacity of elements. The hash function calculates a hash value from the keys.

<a name="NewDefault"></a>
### func [NewDefault](<https://github.com/fufuok/go-freelru/blob/main/helper.go#L9>)

```go
func NewDefault[K comparable, V any](capacity uint32, lifetime ...time.Duration) (*LRU[K, V], error)
```

NewDefault constructs an LRU with the given capacity of elements. The hash function calculates a hash value from the keys.

<a name="NewWithSize"></a>
### func [NewWithSize](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L121>)

```go
func NewWithSize[K comparable, V any](capacity, size uint32, hash HashKeyCallback[K]) (*LRU[K, V], error)
```

NewWithSize constructs an LRU with the given capacity and size. The hash function calculates a hash value from the keys. A size greater than the capacity increases memory consumption and decreases the CPU consumption by reducing the chance of collisions. Size must not be lower than the capacity.

<a name="NewWithSizeDefault"></a>
### func [NewWithSizeDefault](<https://github.com/fufuok/go-freelru/blob/main/helper.go#L18>)

```go
func NewWithSizeDefault[K comparable, V any](capacity, size uint32, lifetime ...time.Duration) (*LRU[K, V], error)
```

NewWithSizeDefault constructs an LRU with the given capacity and size. The hash function calculates a hash value from the keys. A size greater than the capacity increases memory consumption and decreases the CPU consumption by reducing the chance of collisions. Size must not be lower than the capacity.

<a name="LRU[K, V].Add"></a>
### func \(\*LRU\[K, V\]\) [Add](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L416>)

```go
func (lru *LRU[K, V]) Add(key K, value V) (evicted bool)
```

Add adds a key:value to the cache. Returns true, true if key was updated and eviction occurred.

<a name="LRU[K, V].AddWithLifetime"></a>
### func \(\*LRU\[K, V\]\) [AddWithLifetime](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L330>)

```go
func (lru *LRU[K, V]) AddWithLifetime(key K, value V, lifetime time.Duration) (evicted bool)
```

AddWithLifetime adds a key:value to the cache with a lifetime. Returns true, true if key was updated and eviction occurred.

<a name="LRU[K, V].Contains"></a>
### func \(\*LRU\[K, V\]\) [Contains](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L458>)

```go
func (lru *LRU[K, V]) Contains(key K) (ok bool)
```

Contains checks for the existence of a key, without changing its recent\-ness.

<a name="LRU[K, V].Get"></a>
### func \(\*LRU\[K, V\]\) [Get](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L426>)

```go
func (lru *LRU[K, V]) Get(key K) (value V, ok bool)
```

Get looks up a key's value from the cache, setting it as the most recently used item.

<a name="LRU[K, V].Keys"></a>
### func \(\*LRU\[K, V\]\) [Keys](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L490>)

```go
func (lru *LRU[K, V]) Keys() []K
```

Keys returns a slice of the keys in the cache, from oldest to newest.

<a name="LRU[K, V].Len"></a>
### func \(\*LRU\[K, V\]\) [Len](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L324>)

```go
func (lru *LRU[K, V]) Len() int
```

Len returns the number of elements stored in the cache.

<a name="LRU[K, V].Metrics"></a>
### func \(\*LRU\[K, V\]\) [Metrics](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L519>)

```go
func (lru *LRU[K, V]) Metrics() Metrics
```

Metrics returns the metrics of the cache.

<a name="LRU[K, V].Peek"></a>
### func \(\*LRU\[K, V\]\) [Peek](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L445>)

```go
func (lru *LRU[K, V]) Peek(key K) (value V, ok bool)
```

Peek looks up a key's value from the cache, without changing its recent\-ness.

<a name="LRU[K, V].PrintStats"></a>
### func \(\*LRU\[K, V\]\) [PrintStats](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L557>)

```go
func (lru *LRU[K, V]) PrintStats()
```



<a name="LRU[K, V].Purge"></a>
### func \(\*LRU\[K, V\]\) [Purge](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L501>)

```go
func (lru *LRU[K, V]) Purge()
```

Purge purges all data \(key and value\) from the LRU.

<a name="LRU[K, V].Remove"></a>
### func \(\*LRU\[K, V\]\) [Remove](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L470>)

```go
func (lru *LRU[K, V]) Remove(key K) (removed bool)
```

Remove removes the key from the cache. The return value indicates whether the key existed or not.

<a name="LRU[K, V].ResetMetrics"></a>
### func \(\*LRU\[K, V\]\) [ResetMetrics](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L525>)

```go
func (lru *LRU[K, V]) ResetMetrics() Metrics
```

ResetMetrics resets the metrics of the cache and returns the previous state.

<a name="LRU[K, V].SetLifetime"></a>
### func \(\*LRU\[K, V\]\) [SetLifetime](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L99>)

```go
func (lru *LRU[K, V]) SetLifetime(lifetime time.Duration)
```

SetLifetime sets the default lifetime of LRU elements. Lifetime 0 means "forever".

<a name="LRU[K, V].SetOnEvict"></a>
### func \(\*LRU\[K, V\]\) [SetOnEvict](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L106>)

```go
func (lru *LRU[K, V]) SetOnEvict(onEvict OnEvictCallback[K, V])
```

SetOnEvict sets the OnEvict callback function. The onEvict function is called for each evicted lru entry.

<a name="Metrics"></a>
## type [Metrics](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L83-L93>)

Metrics contains metrics about the cache.

```go
type Metrics struct {
    Inserts    uint64
    Collisions uint64
    Evictions  uint64
    Removals   uint64
    Hits       uint64
    Misses     uint64
    Capacity   uint32
    Lifetime   string
    Len        int
}
```

<a name="OnEvictCallback"></a>
## type [OnEvictCallback](<https://github.com/fufuok/go-freelru/blob/main/lru.go#L29>)

OnEvictCallback is the function type for Config.OnEvict.

```go
type OnEvictCallback[K comparable, V any] func(K, V)
```

<a name="ShardedLRU"></a>
## type [ShardedLRU](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L15-L21>)

ShardedLRU is a thread\-safe, sharded, fixed size LRU cache. Sharding is used to reduce lock contention on high concurrency. The downside is that exact LRU behavior is not given \(as for the LRU and SynchedLRU types\).

```go
type ShardedLRU[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewSharded"></a>
### func [NewSharded](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L53>)

```go
func NewSharded[K comparable, V any](capacity uint32, hash HashKeyCallback[K]) (*ShardedLRU[K, V], error)
```

NewSharded creates a new thread\-safe sharded LRU hashmap with the given capacity.

<a name="NewShardedDefault"></a>
### func [NewShardedDefault](<https://github.com/fufuok/go-freelru/blob/main/helper.go#L48>)

```go
func NewShardedDefault[K comparable, V any](capacity uint32, lifetime ...time.Duration) (*ShardedLRU[K, V], error)
```

NewShardedDefault creates a new thread\-safe sharded LRU hashmap with the given capacity.

<a name="NewShardedWithSize"></a>
### func [NewShardedWithSize](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L59-L61>)

```go
func NewShardedWithSize[K comparable, V any](shards, capacity, size uint32, hash HashKeyCallback[K]) (*ShardedLRU[K, V], error)
```



<a name="NewShardedWithSizeDefault"></a>
### func [NewShardedWithSizeDefault](<https://github.com/fufuok/go-freelru/blob/main/helper.go#L59-L61>)

```go
func NewShardedWithSizeDefault[K comparable, V any](shards, capacity, size uint32, lifetime ...time.Duration) (*ShardedLRU[K, V], error)
```



<a name="ShardedLRU[K, V].Add"></a>
### func \(\*ShardedLRU\[K, V\]\) [Add](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L140>)

```go
func (lru *ShardedLRU[K, V]) Add(key K, value V) (evicted bool)
```

Add adds a key:value to the cache. Returns true, true if key was updated and eviction occurred.

<a name="ShardedLRU[K, V].AddWithLifetime"></a>
### func \(\*ShardedLRU\[K, V\]\) [AddWithLifetime](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L127>)

```go
func (lru *ShardedLRU[K, V]) AddWithLifetime(key K, value V, lifetime time.Duration) (evicted bool)
```

AddWithLifetime adds a key:value to the cache with a lifetime. Returns true, true if key was updated and eviction occurred.

<a name="ShardedLRU[K, V].Contains"></a>
### func \(\*ShardedLRU\[K, V\]\) [Contains](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L177>)

```go
func (lru *ShardedLRU[K, V]) Contains(key K) (ok bool)
```

Contains checks for the existence of a key, without changing its recent\-ness.

<a name="ShardedLRU[K, V].Get"></a>
### func \(\*ShardedLRU\[K, V\]\) [Get](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L153>)

```go
func (lru *ShardedLRU[K, V]) Get(key K) (value V, ok bool)
```

Get looks up a key's value from the cache, setting it as the most recently used item.

<a name="ShardedLRU[K, V].Keys"></a>
### func \(\*ShardedLRU\[K, V\]\) [Keys](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L202>)

```go
func (lru *ShardedLRU[K, V]) Keys() []K
```

Keys returns a slice of the keys in the cache, from oldest to newest.

<a name="ShardedLRU[K, V].Len"></a>
### func \(\*ShardedLRU\[K, V\]\) [Len](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L116>)

```go
func (lru *ShardedLRU[K, V]) Len() (length int)
```

Len returns the number of elements stored in the cache.

<a name="ShardedLRU[K, V].Metrics"></a>
### func \(\*ShardedLRU\[K, V\]\) [Metrics](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L223>)

```go
func (lru *ShardedLRU[K, V]) Metrics() Metrics
```

Metrics returns the metrics of the cache.

<a name="ShardedLRU[K, V].Peek"></a>
### func \(\*ShardedLRU\[K, V\]\) [Peek](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L165>)

```go
func (lru *ShardedLRU[K, V]) Peek(key K) (value V, ok bool)
```

Peek looks up a key's value from the cache, without changing its recent\-ness.

<a name="ShardedLRU[K, V].PrintStats"></a>
### func \(\*ShardedLRU\[K, V\]\) [PrintStats](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L275>)

```go
func (lru *ShardedLRU[K, V]) PrintStats()
```



<a name="ShardedLRU[K, V].Purge"></a>
### func \(\*ShardedLRU\[K, V\]\) [Purge](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L214>)

```go
func (lru *ShardedLRU[K, V]) Purge()
```

Purge purges all data \(key and value\) from the LRU.

<a name="ShardedLRU[K, V].Remove"></a>
### func \(\*ShardedLRU\[K, V\]\) [Remove](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L190>)

```go
func (lru *ShardedLRU[K, V]) Remove(key K) (removed bool)
```

Remove removes the key from the cache. The return value indicates whether the key existed or not.

<a name="ShardedLRU[K, V].ResetMetrics"></a>
### func \(\*ShardedLRU\[K, V\]\) [ResetMetrics](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L238>)

```go
func (lru *ShardedLRU[K, V]) ResetMetrics() Metrics
```

ResetMetrics resets the metrics of the cache and returns the previous state.

<a name="ShardedLRU[K, V].SetLifetime"></a>
### func \(\*ShardedLRU\[K, V\]\) [SetLifetime](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L27>)

```go
func (lru *ShardedLRU[K, V]) SetLifetime(lifetime time.Duration)
```

SetLifetime sets the default lifetime of LRU elements. Lifetime 0 means "forever".

<a name="ShardedLRU[K, V].SetOnEvict"></a>
### func \(\*ShardedLRU\[K, V\]\) [SetOnEvict](<https://github.com/fufuok/go-freelru/blob/main/shardedlru.go#L37>)

```go
func (lru *ShardedLRU[K, V]) SetOnEvict(onEvict OnEvictCallback[K, V])
```

SetOnEvict sets the OnEvict callback function. The onEvict function is called for each evicted lru entry.

<a name="SyncedLRU"></a>
## type [SyncedLRU](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L8-L11>)



```go
type SyncedLRU[K comparable, V any] struct {
    // contains filtered or unexported fields
}
```

<a name="NewSynced"></a>
### func [NewSynced](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L32>)

```go
func NewSynced[K comparable, V any](capacity uint32, hash HashKeyCallback[K]) (*SyncedLRU[K, V], error)
```

NewSynced creates a new thread\-safe LRU hashmap with the given capacity.

<a name="NewSyncedDefault"></a>
### func [NewSyncedDefault](<https://github.com/fufuok/go-freelru/blob/main/helper.go#L30>)

```go
func NewSyncedDefault[K comparable, V any](capacity uint32, lifetime ...time.Duration) (*SyncedLRU[K, V], error)
```

NewSyncedDefault creates a new thread\-safe LRU hashmap with the given capacity.

<a name="NewSyncedWithSize"></a>
### func [NewSyncedWithSize](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L36>)

```go
func NewSyncedWithSize[K comparable, V any](capacity, size uint32, hash HashKeyCallback[K]) (*SyncedLRU[K, V], error)
```



<a name="NewSyncedWithSizeDefault"></a>
### func [NewSyncedWithSizeDefault](<https://github.com/fufuok/go-freelru/blob/main/helper.go#L34-L36>)

```go
func NewSyncedWithSizeDefault[K comparable, V any](capacity, size uint32, lifetime ...time.Duration) (*SyncedLRU[K, V], error)
```



<a name="SyncedLRU[K, V].Add"></a>
### func \(\*SyncedLRU\[K, V\]\) [Add](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L67>)

```go
func (lru *SyncedLRU[K, V]) Add(key K, value V) (evicted bool)
```

Add adds a key:value to the cache. Returns true, true if key was updated and eviction occurred.

<a name="SyncedLRU[K, V].AddWithLifetime"></a>
### func \(\*SyncedLRU\[K, V\]\) [AddWithLifetime](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L55>)

```go
func (lru *SyncedLRU[K, V]) AddWithLifetime(key K, value V, lifetime time.Duration) (evicted bool)
```

AddWithLifetime adds a key:value to the cache with a lifetime. Returns true, true if key was updated and eviction occurred.

<a name="SyncedLRU[K, V].Contains"></a>
### func \(\*SyncedLRU\[K, V\]\) [Contains](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L101>)

```go
func (lru *SyncedLRU[K, V]) Contains(key K) (ok bool)
```

Contains checks for the existence of a key, without changing its recent\-ness.

<a name="SyncedLRU[K, V].Get"></a>
### func \(\*SyncedLRU\[K, V\]\) [Get](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L79>)

```go
func (lru *SyncedLRU[K, V]) Get(key K) (value V, ok bool)
```

Get looks up a key's value from the cache, setting it as the most recently used item.

<a name="SyncedLRU[K, V].Keys"></a>
### func \(\*SyncedLRU\[K, V\]\) [Keys](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L124>)

```go
func (lru *SyncedLRU[K, V]) Keys() (keys []K)
```

Keys returns a slice of the keys in the cache, from oldest to newest.

<a name="SyncedLRU[K, V].Len"></a>
### func \(\*SyncedLRU\[K, V\]\) [Len](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L45>)

```go
func (lru *SyncedLRU[K, V]) Len() (length int)
```

Len returns the number of elements stored in the cache.

<a name="SyncedLRU[K, V].Metrics"></a>
### func \(\*SyncedLRU\[K, V\]\) [Metrics](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L140>)

```go
func (lru *SyncedLRU[K, V]) Metrics() Metrics
```

Metrics returns the metrics of the cache.

<a name="SyncedLRU[K, V].Peek"></a>
### func \(\*SyncedLRU\[K, V\]\) [Peek](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L90>)

```go
func (lru *SyncedLRU[K, V]) Peek(key K) (value V, ok bool)
```

Peek looks up a key's value from the cache, without changing its recent\-ness.

<a name="SyncedLRU[K, V].PrintStats"></a>
### func \(\*SyncedLRU\[K, V\]\) [PrintStats](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L162>)

```go
func (lru *SyncedLRU[K, V]) PrintStats()
```



<a name="SyncedLRU[K, V].Purge"></a>
### func \(\*SyncedLRU\[K, V\]\) [Purge](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L133>)

```go
func (lru *SyncedLRU[K, V]) Purge()
```

Purge purges all data \(key and value\) from the LRU.

<a name="SyncedLRU[K, V].Remove"></a>
### func \(\*SyncedLRU\[K, V\]\) [Remove](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L113>)

```go
func (lru *SyncedLRU[K, V]) Remove(key K) (removed bool)
```

Remove removes the key from the cache. The return value indicates whether the key existed or not.

<a name="SyncedLRU[K, V].ResetMetrics"></a>
### func \(\*SyncedLRU\[K, V\]\) [ResetMetrics](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L148>)

```go
func (lru *SyncedLRU[K, V]) ResetMetrics() Metrics
```

ResetMetrics resets the metrics of the cache and returns the previous state.

<a name="SyncedLRU[K, V].SetLifetime"></a>
### func \(\*SyncedLRU\[K, V\]\) [SetLifetime](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L17>)

```go
func (lru *SyncedLRU[K, V]) SetLifetime(lifetime time.Duration)
```

SetLifetime sets the default lifetime of LRU elements. Lifetime 0 means "forever".

<a name="SyncedLRU[K, V].SetOnEvict"></a>
### func \(\*SyncedLRU\[K, V\]\) [SetOnEvict](<https://github.com/fufuok/go-freelru/blob/main/syncedlru.go#L25>)

```go
func (lru *SyncedLRU[K, V]) SetOnEvict(onEvict OnEvictCallback[K, V])
```

SetOnEvict sets the OnEvict callback function. The onEvict function is called for each evicted lru entry.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
